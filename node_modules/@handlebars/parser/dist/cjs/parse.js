import parser from './parser.js';
import WhitespaceControl from './whitespace-control.js';
import * as Helpers from './helpers.js';
var baseHelpers = {};
for (var helper in Helpers) {
    if (Object.prototype.hasOwnProperty.call(Helpers, helper)) {
        baseHelpers[helper] = Helpers[helper];
    }
}
export function parseWithoutProcessing(input, options) {
    var _a, _b, _c;
    // Just return if an already-compiled AST was passed in.
    if (input.type === 'Program') {
        return input;
    }
    parser.yy = baseHelpers;
    // Altering the shared object here, but this is ok as parser is a sync operation
    parser.yy.locInfo = function (locInfo) {
        return new Helpers.SourceLocation(options && options.srcName, locInfo);
    };
    var squareSyntax;
    if (typeof ((_a = options === null || options === void 0 ? void 0 : options.syntax) === null || _a === void 0 ? void 0 : _a.square) === 'function') {
        squareSyntax = options.syntax.square;
    }
    else if (((_b = options === null || options === void 0 ? void 0 : options.syntax) === null || _b === void 0 ? void 0 : _b.square) === 'node') {
        squareSyntax = arrayLiteralNode;
    }
    else {
        squareSyntax = 'string';
    }
    var hashSyntax;
    if (typeof ((_c = options === null || options === void 0 ? void 0 : options.syntax) === null || _c === void 0 ? void 0 : _c.hash) === 'function') {
        hashSyntax = options.syntax.hash;
    }
    else {
        hashSyntax = hashLiteralNode;
    }
    parser.yy.syntax = {
        square: squareSyntax,
        hash: hashSyntax,
    };
    return parser.parse(input);
}
function arrayLiteralNode(array, loc) {
    return {
        type: 'ArrayLiteral',
        items: array,
        loc: loc,
    };
}
function hashLiteralNode(hash, loc) {
    return {
        type: 'HashLiteral',
        pairs: hash.pairs,
        loc: loc,
    };
}
export function parse(input, options) {
    var ast = parseWithoutProcessing(input, options);
    var strip = new WhitespaceControl(options);
    return strip.accept(ast);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvcGFyc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxNQUFNLE1BQU0sYUFBYSxDQUFDO0FBQ2pDLE9BQU8saUJBQWlCLE1BQU0seUJBQXlCLENBQUM7QUFDeEQsT0FBTyxLQUFLLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFFeEMsSUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBRXJCLEtBQUssSUFBSSxNQUFNLElBQUksT0FBTyxFQUFFLENBQUM7SUFDM0IsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDMUQsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxDQUFDO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsT0FBTzs7SUFDbkQsd0RBQXdEO0lBQ3hELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUM3QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxNQUFNLENBQUMsRUFBRSxHQUFHLFdBQVcsQ0FBQztJQUV4QixnRkFBZ0Y7SUFDaEYsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEdBQUcsVUFBVSxPQUFPO1FBQ25DLE9BQU8sSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLENBQUMsQ0FBQztJQUVGLElBQUksWUFBWSxDQUFDO0lBRWpCLElBQUksT0FBTyxDQUFBLE1BQUEsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0sMENBQUUsTUFBTSxDQUFBLEtBQUssVUFBVSxFQUFFLENBQUM7UUFDbEQsWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3ZDLENBQUM7U0FBTSxJQUFJLENBQUEsTUFBQSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSwwQ0FBRSxNQUFNLE1BQUssTUFBTSxFQUFFLENBQUM7UUFDOUMsWUFBWSxHQUFHLGdCQUFnQixDQUFDO0lBQ2xDLENBQUM7U0FBTSxDQUFDO1FBQ04sWUFBWSxHQUFHLFFBQVEsQ0FBQztJQUMxQixDQUFDO0lBRUQsSUFBSSxVQUFVLENBQUM7SUFFZixJQUFJLE9BQU8sQ0FBQSxNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLDBDQUFFLElBQUksQ0FBQSxLQUFLLFVBQVUsRUFBRSxDQUFDO1FBQ2hELFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNuQyxDQUFDO1NBQU0sQ0FBQztRQUNOLFVBQVUsR0FBRyxlQUFlLENBQUM7SUFDL0IsQ0FBQztJQUVELE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHO1FBQ2pCLE1BQU0sRUFBRSxZQUFZO1FBQ3BCLElBQUksRUFBRSxVQUFVO0tBQ2pCLENBQUM7SUFFRixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEdBQUc7SUFDbEMsT0FBTztRQUNMLElBQUksRUFBRSxjQUFjO1FBQ3BCLEtBQUssRUFBRSxLQUFLO1FBQ1osR0FBRyxLQUFBO0tBQ0osQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxJQUFJLEVBQUUsR0FBRztJQUNoQyxPQUFPO1FBQ0wsSUFBSSxFQUFFLGFBQWE7UUFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1FBQ2pCLEdBQUcsS0FBQTtLQUNKLENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxVQUFVLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTztJQUNsQyxJQUFJLEdBQUcsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDakQsSUFBSSxLQUFLLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUUzQyxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDM0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZXIgZnJvbSAnLi9wYXJzZXIuanMnO1xuaW1wb3J0IFdoaXRlc3BhY2VDb250cm9sIGZyb20gJy4vd2hpdGVzcGFjZS1jb250cm9sLmpzJztcbmltcG9ydCAqIGFzIEhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzLmpzJztcblxubGV0IGJhc2VIZWxwZXJzID0ge307XG5cbmZvciAobGV0IGhlbHBlciBpbiBIZWxwZXJzKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoSGVscGVycywgaGVscGVyKSkge1xuICAgIGJhc2VIZWxwZXJzW2hlbHBlcl0gPSBIZWxwZXJzW2hlbHBlcl07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlV2l0aG91dFByb2Nlc3NpbmcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gSnVzdCByZXR1cm4gaWYgYW4gYWxyZWFkeS1jb21waWxlZCBBU1Qgd2FzIHBhc3NlZCBpbi5cbiAgaWYgKGlucHV0LnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIHBhcnNlci55eSA9IGJhc2VIZWxwZXJzO1xuXG4gIC8vIEFsdGVyaW5nIHRoZSBzaGFyZWQgb2JqZWN0IGhlcmUsIGJ1dCB0aGlzIGlzIG9rIGFzIHBhcnNlciBpcyBhIHN5bmMgb3BlcmF0aW9uXG4gIHBhcnNlci55eS5sb2NJbmZvID0gZnVuY3Rpb24gKGxvY0luZm8pIHtcbiAgICByZXR1cm4gbmV3IEhlbHBlcnMuU291cmNlTG9jYXRpb24ob3B0aW9ucyAmJiBvcHRpb25zLnNyY05hbWUsIGxvY0luZm8pO1xuICB9O1xuXG4gIGxldCBzcXVhcmVTeW50YXg7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zPy5zeW50YXg/LnNxdWFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNxdWFyZVN5bnRheCA9IG9wdGlvbnMuc3ludGF4LnNxdWFyZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zPy5zeW50YXg/LnNxdWFyZSA9PT0gJ25vZGUnKSB7XG4gICAgc3F1YXJlU3ludGF4ID0gYXJyYXlMaXRlcmFsTm9kZTtcbiAgfSBlbHNlIHtcbiAgICBzcXVhcmVTeW50YXggPSAnc3RyaW5nJztcbiAgfVxuXG4gIGxldCBoYXNoU3ludGF4O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucz8uc3ludGF4Py5oYXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFzaFN5bnRheCA9IG9wdGlvbnMuc3ludGF4Lmhhc2g7XG4gIH0gZWxzZSB7XG4gICAgaGFzaFN5bnRheCA9IGhhc2hMaXRlcmFsTm9kZTtcbiAgfVxuXG4gIHBhcnNlci55eS5zeW50YXggPSB7XG4gICAgc3F1YXJlOiBzcXVhcmVTeW50YXgsXG4gICAgaGFzaDogaGFzaFN5bnRheCxcbiAgfTtcblxuICByZXR1cm4gcGFyc2VyLnBhcnNlKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gYXJyYXlMaXRlcmFsTm9kZShhcnJheSwgbG9jKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0FycmF5TGl0ZXJhbCcsXG4gICAgaXRlbXM6IGFycmF5LFxuICAgIGxvYyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzaExpdGVyYWxOb2RlKGhhc2gsIGxvYykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdIYXNoTGl0ZXJhbCcsXG4gICAgcGFpcnM6IGhhc2gucGFpcnMsXG4gICAgbG9jLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgbGV0IGFzdCA9IHBhcnNlV2l0aG91dFByb2Nlc3NpbmcoaW5wdXQsIG9wdGlvbnMpO1xuICBsZXQgc3RyaXAgPSBuZXcgV2hpdGVzcGFjZUNvbnRyb2wob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHN0cmlwLmFjY2VwdChhc3QpO1xufVxuIl19