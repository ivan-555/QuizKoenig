{"version":3,"file":"app-ember-satisfies.js","sourceRoot":"","sources":["app-ember-satisfies.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport type { types as t } from '@babel/core';\nimport type State from './state';\nimport { satisfies, coerce } from 'semver';\nimport error from './error';\nimport { assertArray } from './evaluate-json';\nimport { pathToFileURL } from 'url';\nimport { createRequire } from 'module';\nimport { dirname } from 'path';\nimport findUp from 'find-up';\n\nconst packageName = 'ember-source';\nconst CACHE = new Map<string, string | false>();\n/**\n * NOTE: Since there will only ever be one app ember version, we can cache the result of looking it up.\n *       (partly to save disk i/o)\n */\nfunction getAppEmberVersion(state: State): string | false {\n  let appRoot = state.packageCache.appRoot;\n\n  if (CACHE.has(appRoot)) {\n    return CACHE.get(appRoot)!;\n  }\n\n  let root = state.packageCache.get(appRoot);\n\n  if (!root?.hasDependency(packageName)) {\n    CACHE.set(appRoot, false);\n    return false;\n  }\n\n  /**\n   * This version can, and often is a range (^6.4.0),\n   * and using a range for the first parameter of satisfies will cause a failure to always occur.\n   * So we must resolve the actual version on disk.\n   */\n  let resolvedInfo = state.packageCache.resolve(packageName, root);\n  let version = resolvedInfo.version;\n  /**\n   * But, if the version is \"clean\", we can avoid a disk hit\n   * (which is helpful for corporate machines which intercept every disk i/o behavior)\n   */\n  let cleanedVersion = String(coerce(version, { includePrerelease: true }));\n\n  /**\n   * these are the same, so we don't need to ask the disk what was installed\n   */\n  if (cleanedVersion === version) {\n    CACHE.set(appRoot, version);\n    return version;\n  }\n\n  const appURL = pathToFileURL(appRoot);\n  const require = createRequire(appURL);\n  const emberSourceEntry = require.resolve(packageName, {\n    paths: [appRoot],\n  });\n  const emberSourceManifestPath = findUp.sync('package.json', { cwd: dirname(emberSourceEntry) });\n\n  if (!emberSourceManifestPath) {\n    throw new Error(`We resolved an ember-source package, but could not find its package.json`);\n  }\n  const emberSourceManifest = require(emberSourceManifestPath);\n\n  CACHE.set(appRoot, emberSourceManifest.version);\n  return emberSourceManifest.version;\n}\n\nexport default function appEmberSatisfies(path: NodePath<t.CallExpression>, state: State): boolean {\n  if (path.node.arguments.length !== 1) {\n    throw error(path, `appEmberSatisfies takes exactly one argument, you passed ${path.node.arguments.length}`);\n  }\n  const [range] = path.node.arguments;\n  if (range.type !== 'StringLiteral') {\n    throw error(\n      assertArray(path.get('arguments'))[0],\n      `the only argument to appEmberSatisfies must be a string literal`\n    );\n  }\n  try {\n    let appEmberVersion = getAppEmberVersion(state);\n\n    if (!appEmberVersion) {\n      return false;\n    }\n\n    return satisfies(appEmberVersion, range.value, {\n      includePrerelease: true,\n    });\n  } catch (err) {\n    if (err.code !== 'MODULE_NOT_FOUND') {\n      throw err;\n    }\n    return false;\n  }\n}\n"]}