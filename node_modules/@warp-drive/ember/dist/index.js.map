{"version":3,"file":"index.js","sources":["../src/-private/await.gts","../../../node_modules/.pnpm/decorat_bfe8edbefc8aced6f61ce140cd72ecf2/node_modules/decorator-transforms/dist/runtime-BPCpkOf1.js","../src/-private/request.gts"],"sourcesContent":["/**\n * @module @warp-drive/ember\n */\nimport type Owner from '@ember/owner';\nimport Component from '@glimmer/component';\n\nimport type { Awaitable } from '@ember-data/request';\nimport { getPromiseState } from '@ember-data/store/-private';\n\nexport const and = (x: unknown, y: unknown) => Boolean(x && y);\ninterface ThrowSignature<E = Error | string | object> {\n  Args: {\n    error: E;\n  };\n}\n\n/**\n * The `<Throw />` component is used to throw an error in a template.\n *\n * That's all it does. So don't use it unless the application should\n * throw an error if it reaches this point in the template.\n *\n * ```hbs\n * <Throw @error={{anError}} />\n * ```\n *\n * @class <Throw />\n * @public\n */\nexport class Throw<T> extends Component<ThrowSignature<T>> {\n  constructor(owner: Owner, args: ThrowSignature<T>['Args']) {\n    super(owner, args);\n    // this error is opaque (user supplied) so we don't validate it\n    // as an Error instance.\n    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n    throw this.args.error;\n  }\n  <template></template>\n}\n\ninterface AwaitSignature<T, E = Error | string | object> {\n  Args: {\n    promise: Promise<T> | Awaitable<T, E>;\n  };\n  Blocks: {\n    pending: [];\n    error: [error: E];\n    success: [value: T];\n  };\n}\n\n/**\n * The <Await /> component allow you to utilize reactive control flow\n * for asynchronous states in your application.\n *\n * Await is ideal for handling \"boundaries\", outside which some state is\n * still allowed to be unresolved and within which it MUST be resolved.\n *\n * ```gjs\n * import { Await } from '@warp-drive/ember';\n *\n * <template>\n *   <Await @promise={{@request}}>\n *     <:pending>\n *       <Spinner />\n *     </:pending>\n *\n *     <:error as |error|>\n *       <ErrorForm @error={{error}} />\n *     </:error>\n *\n *     <:success as |result|>\n *       <h1>{{result.title}}</h1>\n *     </:success>\n *   </Await>\n * </template>\n * ```\n *\n * The <Await /> component requires that error states are properly handled.\n *\n * If no error block is provided and the promise rejects, the error will\n * be thrown.\n *\n * @class <Await />\n * @public\n */\nexport class Await<T, E> extends Component<AwaitSignature<T, E>> {\n  get state() {\n    return getPromiseState<T, E>(this.args.promise);\n  }\n\n  get error() {\n    return this.state.error as E;\n  }\n\n  get result() {\n    return this.state.result as T;\n  }\n\n  <template>\n    {{#if this.state.isPending}}\n      {{yield to=\"pending\"}}\n    {{else if (and this.state.isError (has-block \"error\"))}}\n      {{yield this.error to=\"error\"}}\n    {{else if this.state.isSuccess}}\n      {{yield this.result to=\"success\"}}\n    {{else}}\n      <Throw @error={{this.error}} />\n    {{/if}}\n  </template>\n}\n","const deferred = /* @__PURE__ */ new WeakMap();\nfunction deferDecorator(proto, prop, desc) {\n  let map = deferred.get(proto);\n  if (!map) {\n    map = /* @__PURE__ */ new Map();\n    deferred.set(proto, map);\n  }\n  map.set(prop, desc);\n}\nfunction findDeferredDecorator(target, prop) {\n  var _a;\n  let cursor = target.prototype;\n  while (cursor) {\n    let desc = (_a = deferred.get(cursor)) == null ? void 0 : _a.get(prop);\n    if (desc) {\n      return desc;\n    }\n    cursor = cursor.prototype;\n  }\n}\nfunction decorateFieldV1(target, prop, decorators, initializer) {\n  return decorateFieldV2(target.prototype, prop, decorators, initializer);\n}\nfunction decorateFieldV2(prototype, prop, decorators, initializer) {\n  let desc = {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    initializer: null\n  };\n  if (initializer) {\n    desc.initializer = initializer;\n  }\n  for (let decorator of decorators) {\n    desc = decorator(prototype, prop, desc) || desc;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(prototype, prop, desc);\n  } else {\n    deferDecorator(prototype, prop, desc);\n  }\n}\nfunction decorateMethodV1({ prototype }, prop, decorators) {\n  return decorateMethodV2(prototype, prop, decorators);\n}\nfunction decorateMethodV2(prototype, prop, decorators) {\n  const origDesc = Object.getOwnPropertyDescriptor(prototype, prop);\n  let desc = { ...origDesc };\n  for (let decorator of decorators) {\n    desc = decorator(prototype, prop, desc) || desc;\n  }\n  if (desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(prototype) : void 0;\n    desc.initializer = void 0;\n  }\n  Object.defineProperty(prototype, prop, desc);\n}\nfunction initializeDeferredDecorator(target, prop) {\n  let desc = findDeferredDecorator(target.constructor, prop);\n  if (desc) {\n    Object.defineProperty(target, prop, {\n      enumerable: desc.enumerable,\n      configurable: desc.configurable,\n      writable: desc.writable,\n      value: desc.initializer ? desc.initializer.call(target) : void 0\n    });\n  }\n}\nfunction decorateClass(target, decorators) {\n  return decorators.reduce(\n    (accum, decorator) => decorator(accum) || accum,\n    target\n  );\n}\nfunction decoratePOJO(pojo, decorated) {\n  for (let [type, prop, decorators] of decorated) {\n    if (type === \"field\") {\n      decoratePojoField(pojo, prop, decorators);\n    } else {\n      decorateMethodV2(pojo, prop, decorators);\n    }\n  }\n  return pojo;\n}\nfunction decoratePojoField(pojo, prop, decorators) {\n  let desc = {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    initializer: () => {\n      var _a;\n      return (_a = Object.getOwnPropertyDescriptor(pojo, prop)) == null ? void 0 : _a.value;\n    }\n  };\n  for (let decorator of decorators) {\n    desc = decorator(pojo, prop, desc) || desc;\n  }\n  if (desc.initializer) {\n    desc.value = desc.initializer.call(pojo);\n    delete desc.initializer;\n  }\n  Object.defineProperty(pojo, prop, desc);\n}\nconst runtime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  c: decorateClass,\n  f: decorateFieldV1,\n  g: decorateFieldV2,\n  i: initializeDeferredDecorator,\n  m: decorateMethodV1,\n  n: decorateMethodV2,\n  p: decoratePOJO\n}, Symbol.toStringTag, { value: \"Module\" }));\nexport {\n  decorateFieldV2 as a,\n  decorateMethodV1 as b,\n  decorateMethodV2 as c,\n  decorateFieldV1 as d,\n  decorateClass as e,\n  decoratePOJO as f,\n  initializeDeferredDecorator as i,\n  runtime as r\n};\n//# sourceMappingURL=runtime-BPCpkOf1.js.map\n","/**\n * @module @warp-drive/ember\n */\nimport type Owner from '@ember/owner';\nimport { service } from '@ember/service';\nimport Component from '@glimmer/component';\nimport { cached, tracked } from '@glimmer/tracking';\n\nimport { importSync, macroCondition, moduleExists } from '@embroider/macros';\n\nimport type { Future, StructuredErrorDocument } from '@ember-data/request';\nimport type { StoreRequestInput } from '@ember-data/store';\nimport type Store from '@ember-data/store';\nimport type { RequestLoadingState, RequestState } from '@ember-data/store/-private';\nimport { getRequestState } from '@ember-data/store/-private';\nimport { assert } from '@warp-drive/build-config/macros';\nimport type { StableDocumentIdentifier } from '@warp-drive/core-types/identifier.js';\nimport { EnableHydration, type RequestInfo } from '@warp-drive/core-types/request';\n\nimport { and, Throw } from './await.gts';\n\nfunction notNull(x: null): never;\nfunction notNull<T>(x: T): Exclude<T, null>;\nfunction notNull<T>(x: T | null) {\n  assert('Expected a non-null value, but got null', x !== null);\n  return x;\n}\n\nconst not = (x: unknown) => !x;\n// default to 30 seconds unavailable before we refresh\nconst DEFAULT_DEADLINE = 30_000;\nconst IdleBlockMissingError = new Error(\n  'No idle block provided for <Request> component, and no query or request was provided.'\n);\n\nlet consume = service;\nif (macroCondition(moduleExists('ember-provide-consume-context'))) {\n  const { consume: contextConsume } = importSync('ember-provide-consume-context') as { consume: typeof service };\n  consume = contextConsume;\n}\n\nfunction isNeverString(val: never): string {\n  return val;\n}\n\ntype AutorefreshBehaviorType = 'online' | 'interval' | 'invalid';\ntype AutorefreshBehaviorCombos =\n  | boolean\n  | AutorefreshBehaviorType\n  | `${AutorefreshBehaviorType},${AutorefreshBehaviorType}`\n  | `${AutorefreshBehaviorType},${AutorefreshBehaviorType},${AutorefreshBehaviorType}`;\n\ntype ContentFeatures<RT> = {\n  isOnline: boolean;\n  isHidden: boolean;\n  isRefreshing: boolean;\n  refresh: () => Promise<void>;\n  reload: () => Promise<void>;\n  abort?: () => void;\n  latestRequest?: Future<RT>;\n};\n\ninterface RequestSignature<T, RT, E> {\n  Args: {\n    /**\n     * The request to monitor. This should be a `Future` instance returned\n     * by either the `store.request` or `store.requestManager.request` methods.\n     *\n     * @typedoc\n     */\n    request?: Future<RT>;\n\n    /**\n     * A query to use for the request. This should be an object that can be\n     * passed to `store.request`. Use this in place of `@request` if you would\n     * like the component to also initiate the request.\n     *\n     * @typedoc\n     */\n    query?: StoreRequestInput<T, RT>;\n\n    /**\n     * The store instance to use for making requests. If contexts are available,\n     * the component will default to using the `store` on the context.\n     *\n     * This is required if the store is not available via context or should be\n     * different from the store provided via context.\n     *\n     * @typedoc\n     */\n    store?: Store;\n\n    /**\n     * The autorefresh behavior for the request. This can be a boolean, or any\n     * combination of the following values: `'online'`, `'interval'`, `'invalid'`.\n     *\n     * - `'online'`: Refresh the request when the browser comes back online\n     * - `'interval'`: Refresh the request at a specified interval\n     * - `'invalid'`: Refresh the request when the store emits an invalidation\n     *\n     * If `true`, this is equivalent to `'online,invalid'`.\n     *\n     * Defaults to `false`.\n     *\n     * @typedoc\n     */\n    autorefresh?: AutorefreshBehaviorCombos;\n\n    /**\n     * The number of milliseconds to wait before refreshing the request when the\n     * browser comes back online or the network becomes available.\n     *\n     * This also controls the interval at which the request will be refreshed if\n     * the `interval` autorefresh type is enabled.\n     *\n     * Defaults to `30_000` (30 seconds).\n     *\n     * @typedoc\n     */\n    autorefreshThreshold?: number;\n\n    /**\n     * The behavior of the request initiated by autorefresh. This can be one of\n     * the following values:\n     *\n     * - `'refresh'`: Refresh the request in the background\n     * - `'reload'`: Force a reload of the request\n     * - `'policy'` (**default**): Let the store's configured CachePolicy decide whether to\n     *    reload, refresh, or do nothing.\n     *\n     * Defaults to `'policy'`.\n     *\n     * @typedoc\n     */\n    autorefreshBehavior?: 'refresh' | 'reload' | 'policy';\n  };\n  Blocks: {\n    /**\n     * The block to render when the component is idle and waiting to be given a request.\n     *\n     * @typedoc\n     */\n    idle: [];\n\n    /**\n     * The block to render when the request is loading.\n     *\n     * @typedoc\n     */\n    loading: [state: RequestLoadingState];\n\n    /**\n     * The block to render when the request was cancelled.\n     *\n     * @typedoc\n     */\n    cancelled: [\n      error: StructuredErrorDocument<E>,\n      features: { isOnline: boolean; isHidden: boolean; retry: () => Promise<void> },\n    ];\n\n    /**\n     * The block to render when the request failed. If this block is not provided,\n     * the error will be rethrown.\n     *\n     * Thus it is required to provide an error block and proper error handling if\n     * you do not want the error to crash the application.\n     *\n     * @typedoc\n     */\n    error: [\n      error: StructuredErrorDocument<E>,\n      features: { isOnline: boolean; isHidden: boolean; retry: () => Promise<void> },\n    ];\n\n    /**\n     * The block to render when the request succeeded.\n     *\n     * @typedoc\n     */\n    content: [value: RT, features: ContentFeatures<RT>];\n    always: [state: RequestState<T, RT, StructuredErrorDocument<E>>];\n  };\n}\n\n/**\n * The `<Request />` component is a powerful tool for managing data fetching and\n * state in your Ember application. It provides a declarative approach to reactive\n * control-flow for managing requests and state in your application.\n *\n * The `<Request />` component is ideal for handling \"boundaries\", outside which some\n * state is still allowed to be unresolved and within which it MUST be resolved.\n *\n * ## Request States\n *\n * `<Request />` has five states, only one of which will be active and rendered at a time.\n *\n * - `idle`: The component is waiting to be given a request to monitor\n * - `loading`: The request is in progress\n * - `error`: The request failed\n * - `content`: The request succeeded\n * - `cancelled`: The request was cancelled\n *\n * Additionally, the `content` state has a `refresh` method that can be used to\n * refresh the request in the background, which is available as a sub-state of\n * the `content` state.\n *\n * As with the `<Await />` component, if no error block is provided and the request\n * rejects, the error will be thrown. Cancellation errors are swallowed instead of\n * rethrown if no error block or cancellation block is present.\n *\n * ```gts\n * import { Request } from '@warp-drive/ember';\n *\n * <template>\n *   <Request @request={{@request}}>\n *     <:loading as |state|>\n *       <Spinner @percentDone={{state.completedRatio}} />\n *       <button {{on \"click\" state.abort}}>Cancel</button>\n *     </:loading>\n *\n *     <:error as |error state|>\n *       <ErrorForm @error={{error}} />\n *       <button {{on \"click\" state.retry}}>Retry</button>\n *     </:error>\n *\n *     <:content as |data state|>\n *       <h1>{{data.title}}</h1>\n *       {{#if state.isBackgroundReloading}}\n *         <SmallSpinner />\n *         <button {{on \"click\" state.abort}}>Cancel</button>\n *       {{else}}\n *         <button {{on \"click\" state.refresh}}>Refresh</button>\n *       {{/if}}\n *     </:content>\n *\n *     <:cancelled as |error state|>\n *       <h2>The Request was cancelled</h2>\n *       <button {{on \"click\" state.retry}}>Retry</button>\n *     </:cancelled>\n *\n *     <:idle>\n *       <button {{on \"click\" @kickOffRequest}}>Load Preview?</button>\n *     </:idle>\n *\n *   </Request>\n * </template>\n * ```\n *\n * ## Streaming Data\n *\n * The loading state exposes the download `ReadableStream` instance for consumption\n *\n * ```gjs\n * import { Request } from '@warp-drive/ember';\n *\n * <template>\n *   <Request @request={{@request}}>\n *     <:loading as |state|>\n *       <Video @stream={{state.stream}} />\n *     </:loading>\n *\n *     <:error as |error|>\n *       <ErrorForm @error={{error}} />\n *     </:error>\n *   </Request>\n * </template>\n * ```\n *\n * ## Retry\n *\n * Cancelled and error'd requests may be retried by calling the `retry` method.\n *\n * Retry will restart the state progression, using the loading, error, cancelled,\n * and content blocks as appropriate.\n *\n * ## Reloading\n *\n * The `reload` method will force the request to be fully re-executed, bypassing\n * cache and restarting the state progression through the loading, error, and\n * content blocks as appropriate.\n *\n * Background reload (refresh) is a special substate of the content state that\n * allows you to refresh the request in the background. This is useful for when\n * you want to update the data in the background without blocking the UI.\n *\n * Reload and refresh are available as methods on the `content` state.\n *\n * ```gjs\n * import { Request } from '@warp-drive/ember';\n *\n * <template>\n *   <Request @request={{@request}}>\n *     <:content as |data state|>\n *       <h1>{{data.title}}</h1>\n *       {{#if state.isBackgroundReloading}}\n *         <SmallSpinner />\n *         <button {{on \"click\" state.abort}}>Cancel</button>\n *       {{/if}}\n *\n *       <button {{on \"click\" state.refresh}}>Refresh</button>\n *       <button {{on \"click\" state.reload}}>Reload</button>\n *     </:content>\n *  </Request>\n * </template>\n * ```\n *\n * ## Advanced Reloading\n *\n * We can nest our usage of `<Request />` to handle more advanced\n * reloading scenarios.\n *\n * ```gjs\n * import { Request } from '@warp-drive/ember';\n *\n * <template>\n *   <Request @request={{@request}}>\n *     <:cancelled>\n *       <h2>The Request Cancelled</h2>\n *     </:cancelled>\n *\n *     <:error as |error|>\n *       <ErrorForm @error={{error}} />\n *     </:error>\n *\n *     <:content as |result state|>\n *       <Request @request={{state.latestRequest}}>\n *         <!-- Handle Background Request -->\n *       </Request>\n *\n *       <h1>{{result.title}}</h1>\n *\n *       <button {{on \"click\" state.refresh}}>Refresh</button>\n *     </:content>\n *   </Request>\n * </template>\n * ```\n *\n * ## Autorefresh\n *\n * `<Request />` supports automatic refresh and reload under certain conditions.\n *\n * - `online`: This occurs when a browser window or tab comes back to the foreground\n *   after being backgrounded or when the network reports as being online after\n *   having been offline.\n * - `interval`: This occurs when a specified amount of time has passed.\n * - `invalid`: This occurs when the store emits a notification that the request\n *   has become invalid.\n *\n * You can specify when autorefresh should occur by setting the `autorefresh` arg\n * to `true` or a comma-separated list of the above values.\n *\n * A value of `true` is equivalent to `'online,invalid'`.\n *\n * By default, an autorefresh will only occur if the browser was backgrounded or\n * offline for more than 30s before coming back available. This amount of time can\n * be tweaked by setting the number of milliseconds via `@autorefreshThreshold`.\n *\n * This arg also controls the interval at which the request will be refreshed\n * if the `interval` autorefresh type is enabled.\n *\n * Finally, the behavior of the request initiated by autorefresh can be adjusted\n * by setting the `autorefreshBehavior` arg to `'refresh'`, `'reload'`, or `'policy'`.\n *\n * - `'refresh'`: Refresh the request in the background\n * - `'reload'`: Force a reload of the request\n * - `'policy'` (**default**): Let the store's configured CachePolicy decide whether to\n *    reload, refresh, or do nothing.\n *\n * More advanced refresh and reload behaviors can be created by passing the reload and\n * refresh actions into another component. For instance, refresh could be set up on a\n * timer or on a websocket subscription.\n *\n *\n * ```gjs\n * import { Request } from '@warp-drive/ember';\n *\n * <template>\n *   <Request @request={{@request}}>\n *     <:content as |result state|>\n *       <h1>{{result.title}}</h1>\n *\n *       <Interval @period={{30_000}} @fn={{state.refresh}} />\n *       <Subscribe @channel={{@someValue}} @fn={{state.refresh}} />\n *     </:content>\n *   </Request>\n * </template>\n * ```\n *\n * If a matching request is refreshed or reloaded by any other component,\n * the `Request` component will react accordingly.\n *\n * ## Deduping\n *\n * The store dedupes requests by identity. If a request is made for the same identity\n * from multiple `<Request />` components, even if the request is not referentially the\n * same, only one actual request will be made.\n *\n *\n * @class <Request />\n * @public\n */\nexport class Request<T, RT, E> extends Component<RequestSignature<T, RT, E>> {\n  /**\n   * The store instance to use for making requests. If contexts are available, this\n   * will be the `store` on the context, else it will be the store service.\n   *\n   * @internal\n   */\n  @consume('store') declare _store: Store;\n\n  /**\n   * Whether the browser reports that the network is online.\n   *\n   * @internal\n   */\n  @tracked isOnline = true;\n\n  /**\n   * Whether the browser reports that the tab is hidden.\n   *\n   * @internal\n   */\n  @tracked isHidden = true;\n\n  /**\n   * Whether the component is currently refreshing the request.\n   *\n   * @internal\n   */\n  @tracked isRefreshing = false;\n\n  /**\n   * The most recent blocking request that was made, typically\n   * the result of a reload.\n   *\n   * This will never be the original request passed as an arg to\n   * the component.\n   *\n   * @internal\n   */\n  @tracked _localRequest: Future<RT> | undefined;\n\n  /**\n   * The most recent request that was made, typically due to either a\n   * reload or a refresh.\n   *\n   * This will never be the original request passed as an arg to\n   * the component.\n   *\n   * @internal\n   */\n  @tracked _latestRequest: Future<RT> | undefined;\n\n  /**\n   * The time at which the network was reported as offline.\n   *\n   * @internal\n   */\n  declare unavailableStart: number | null;\n  declare intervalStart: number | null;\n  declare nextInterval: number | null;\n  declare invalidated: boolean;\n  declare isUpdating: boolean;\n\n  /**\n   * The event listener for network status changes,\n   * cached to use the reference for removal.\n   *\n   * @internal\n   */\n  declare onlineChanged: (event: Event) => void;\n\n  /**\n   * The event listener for visibility status changes,\n   * cached to use the reference for removal.\n   *\n   * @internal\n   */\n  declare backgroundChanged: (event: Event) => void;\n\n  /**\n   * The last request passed as an arg to the component,\n   * cached for comparison.\n   *\n   * @internal\n   */\n  declare _originalRequest: Future<RT> | undefined;\n\n  /**\n   * The last query passed as an arg to the component,\n   * cached for comparison.\n   *\n   * @internal\n   */\n  declare _originalQuery: StoreRequestInput<T, RT> | undefined;\n\n  declare _subscription: object | null;\n  declare _subscribedTo: object | null;\n\n  constructor(owner: Owner, args: RequestSignature<T, RT, E>['Args']) {\n    super(owner, args);\n    this._subscribedTo = null;\n    this._subscription = null;\n    this.intervalStart = null;\n    this.invalidated = false;\n    this.nextInterval = null;\n\n    this.installListeners();\n    void this.beginPolling();\n  }\n\n  async beginPolling() {\n    // await the initial request\n    try {\n      await this.request;\n    } catch {\n      // ignore errors here, we just want to wait for the request to finish\n    } finally {\n      if (!this.isDestroyed) {\n        void this.scheduleInterval();\n      }\n    }\n  }\n\n  @cached\n  get isIdle() {\n    const { request, query } = this.args;\n\n    return Boolean(!request && !query);\n  }\n\n  @cached\n  get autorefreshTypes(): Set<AutorefreshBehaviorType> {\n    const { autorefresh } = this.args;\n    let types: AutorefreshBehaviorType[];\n\n    if (autorefresh === true) {\n      types = ['online', 'invalid'];\n    } else if (typeof autorefresh === 'string') {\n      types = autorefresh.split(',') as AutorefreshBehaviorType[];\n    } else {\n      types = [];\n    }\n\n    return new Set(types);\n  }\n\n  // we only run this function on component creation\n  // and when an update is triggered, so it does not\n  // react to changes in the autorefreshThreshold\n  // or autorefresh args.\n  //\n  // if we need to react to those changes, we can\n  // use a modifier or internal component or some\n  // such to trigger a re-run of this function.\n  async scheduleInterval() {\n    const { autorefreshThreshold } = this.args;\n    const hasValidThreshold = typeof autorefreshThreshold === 'number' && autorefreshThreshold > 0;\n    if (\n      // dont schedule in SSR\n      typeof window === 'undefined' ||\n      // dont schedule without a threshold\n      !hasValidThreshold ||\n      // dont schedule if we weren't told to\n      !this.autorefreshTypes.has('interval') ||\n      // dont schedule if we're already scheduled\n      this.intervalStart !== null\n    ) {\n      return;\n    }\n\n    // if we have a current request, wait for it to finish\n    // before scheduling the next one\n    if (this._latestRequest) {\n      try {\n        await this._latestRequest;\n      } catch {\n        // ignore errors here, we just want to wait for the request to finish\n      }\n\n      if (this.isDestroyed) {\n        return;\n      }\n    }\n\n    // setup the next interval\n    this.intervalStart = Date.now();\n    this.nextInterval = setTimeout(() => {\n      this.maybeUpdate();\n    }, autorefreshThreshold) as unknown as number;\n  }\n\n  clearInterval() {\n    if (this.nextInterval) {\n      clearTimeout(this.nextInterval);\n      this.intervalStart = null;\n    }\n  }\n\n  updateSubscriptions() {\n    if (this.isIdle) {\n      return;\n    }\n    const requestId = this._request.lid;\n\n    // if we're already subscribed to this request, we don't need to do anything\n    if (this._subscribedTo === requestId) {\n      return;\n    }\n\n    // if we're subscribed to a different request, we need to unsubscribe\n    this.removeSubscriptions();\n\n    // if we have a request, we need to subscribe to it\n    if (requestId) {\n      this._subscribedTo = requestId;\n      this._subscription = this.store.notifications.subscribe(\n        requestId,\n        (_id: StableDocumentIdentifier, op: 'invalidated' | 'state' | 'added' | 'updated' | 'removed') => {\n          // ignore subscription events that occur while our own component's request\n          // is ocurring\n          if (this.isUpdating) {\n            return;\n          }\n          switch (op) {\n            case 'invalidated': {\n              // if we're subscribed to invalidations, we need to update\n              if (this.autorefreshTypes.has('invalid')) {\n                this.invalidated = true;\n                this.maybeUpdate();\n              }\n              break;\n            }\n            case 'state': {\n              const latest = this.store.requestManager._deduped.get(requestId);\n              const priority = latest?.priority;\n              const state = this.reqState;\n              if (!priority) {\n                // if there is no priority, we have completed whatever request\n                // was occurring and so we are no longer refreshing (if we were)\n                this.isRefreshing = false;\n              } else if (priority.blocking && !state.isLoading) {\n                // if we are blocking, there is an active request for this identity\n                // that MUST be fulfilled from network (not cache).\n                // Thus this is not \"refreshing\" because we should clear out and\n                // block on this request.\n                //\n                // we receive state notifications when either a request initiates\n                // or completes.\n                //\n                // In the completes case: we may receive the state notification\n                // slightly before the request is finalized because the NotificationManager\n                // may sync flush it (and thus deliver it before the microtask completes)\n                //\n                // In the initiates case: we aren't supposed to receive one unless there\n                // is no other request in flight for this identity.\n                //\n                // However, there is a race condition here where the completed\n                // notification can trigger an update that generates a new request\n                // thus giving us an initiated notification before the older request\n                // finalizes.\n                //\n                // When this occurs, if the triggered update happens to have caused\n                // a new request to be made for the same identity AND that request\n                // is the one passed into this component as the @request arg, then\n                // getRequestState will return the state of the new request.\n                // We can detect this by checking if the request state is \"loading\"\n                // as outside of this case we would have a completed request.\n                //\n                // That is the reason for the `&& !state.isLoading` check above.\n\n                // TODO should we just treat this as refreshing?\n                this.isRefreshing = false;\n                this.maybeUpdate('policy', true);\n              } else {\n                this.isRefreshing = true;\n              }\n            }\n          }\n        }\n      );\n    }\n  }\n\n  removeSubscriptions() {\n    if (this._subscription) {\n      this.store.notifications.unsubscribe(this._subscription);\n      this._subscribedTo = null;\n      this._subscription = null;\n    }\n  }\n\n  /**\n   * Install the event listeners for network and visibility changes.\n   * This is only done in browser environments with a global `window`.\n   *\n   * @internal\n   */\n  installListeners() {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    this.isOnline = window.navigator.onLine;\n    this.unavailableStart = this.isOnline ? null : Date.now();\n    this.isHidden = document.visibilityState === 'hidden';\n\n    this.onlineChanged = (event: Event) => {\n      this.isOnline = event.type === 'online';\n      if (event.type === 'offline' && this.unavailableStart === null) {\n        this.unavailableStart = Date.now();\n      }\n      this.maybeUpdate();\n    };\n    this.backgroundChanged = () => {\n      const isHidden = document.visibilityState === 'hidden';\n      this.isHidden = isHidden;\n\n      if (isHidden && this.unavailableStart === null) {\n        this.unavailableStart = Date.now();\n      }\n\n      this.maybeUpdate();\n    };\n\n    window.addEventListener('online', this.onlineChanged, { passive: true, capture: true });\n    window.addEventListener('offline', this.onlineChanged, { passive: true, capture: true });\n    document.addEventListener('visibilitychange', this.backgroundChanged, { passive: true, capture: true });\n  }\n\n  /**\n   * If the network is online and the tab is visible, either reload or refresh the request\n   * based on the component's configuration and the requested update mode.\n   *\n   * Valid modes are:\n   *\n   * - `'reload'`: Force a reload of the request.\n   * - `'refresh'`: Refresh the request in the background.\n   * - `'policy'`: Make the request, letting the store's configured CachePolicy decide whether to reload, refresh, or do nothing.\n   * - `undefined`: Make the request using the component's autorefreshBehavior setting if the autorefreshThreshold has passed.\n   *\n   * @internal\n   */\n  maybeUpdate(mode?: 'reload' | 'refresh' | 'policy' | 'invalidated', silent?: boolean): void {\n    if (this.isIdle) {\n      return;\n    }\n    const canAttempt = Boolean(this.isOnline && !this.isHidden && (mode || this.autorefreshTypes.size));\n\n    if (!canAttempt) {\n      if (!silent && mode && mode !== 'invalidated') {\n        throw new Error(`Reload not available: the network is not online or the tab is hidden`);\n      }\n\n      return;\n    }\n\n    const { autorefreshTypes } = this;\n    let shouldAttempt = this.invalidated || Boolean(mode);\n\n    if (!shouldAttempt && autorefreshTypes.has('online')) {\n      const { unavailableStart } = this;\n      const { autorefreshThreshold } = this.args;\n      const deadline = typeof autorefreshThreshold === 'number' ? autorefreshThreshold : DEFAULT_DEADLINE;\n      shouldAttempt = Boolean(unavailableStart && Date.now() - unavailableStart > deadline);\n    }\n\n    if (!shouldAttempt && autorefreshTypes.has('interval')) {\n      const { intervalStart } = this;\n      const { autorefreshThreshold } = this.args;\n\n      if (intervalStart && typeof autorefreshThreshold === 'number' && autorefreshThreshold > 0) {\n        shouldAttempt = Boolean(Date.now() - intervalStart >= autorefreshThreshold);\n      }\n    }\n\n    this.unavailableStart = null;\n    this.invalidated = false;\n\n    if (shouldAttempt) {\n      this.clearInterval();\n      const request = Object.assign({}, this.reqState.request as unknown as RequestInfo<T, RT>);\n      const realMode = mode === 'invalidated' ? null : mode;\n      const val = realMode ?? this.args.autorefreshBehavior ?? 'policy';\n      switch (val) {\n        case 'reload':\n          request.cacheOptions = Object.assign({}, request.cacheOptions, { reload: true });\n          break;\n        case 'refresh':\n          request.cacheOptions = Object.assign({}, request.cacheOptions, { backgroundReload: true });\n          break;\n        case 'policy':\n          break;\n        default:\n          throw new Error(\n            `Invalid ${mode ? 'update mode' : '@autorefreshBehavior'} for <Request />: ${isNeverString(val)}`\n          );\n      }\n\n      const wasStoreRequest = request[EnableHydration] === true;\n      assert(\n        `Cannot supply a different store via context than was used to create the request`,\n        !request.store || request.store === this.store\n      );\n\n      this.isUpdating = true;\n      this._latestRequest = wasStoreRequest ? this.store.request(request) : this.store.requestManager.request(request);\n\n      if (val !== 'refresh') {\n        this._localRequest = this._latestRequest;\n      }\n\n      void this.scheduleInterval();\n      void this._latestRequest.finally(() => {\n        this.isUpdating = false;\n      });\n    } else {\n      // TODO probably want this\n      // void this.scheduleInterval();\n    }\n  }\n\n  /**\n   * Retry the request, reloading it from the server.\n   *\n   * @internal\n   */\n  retry = async () => {\n    this.maybeUpdate('reload');\n    await this._localRequest;\n  };\n\n  /**\n   * Refresh the request, updating it in the background.\n   *\n   * @internal\n   */\n  refresh = async () => {\n    this.maybeUpdate('refresh');\n    await this._latestRequest;\n  };\n\n  @cached\n  get errorFeatures() {\n    return {\n      isHidden: this.isHidden,\n      isOnline: this.isOnline,\n      retry: this.retry,\n    };\n  }\n\n  @cached\n  get contentFeatures() {\n    const feat: ContentFeatures<RT> = {\n      isHidden: this.isHidden,\n      isOnline: this.isOnline,\n      reload: this.retry,\n      refresh: this.refresh,\n      isRefreshing: this.isRefreshing,\n      latestRequest: this._latestRequest,\n    };\n\n    if (feat.isRefreshing) {\n      feat.abort = () => {\n        this._latestRequest?.abort();\n      };\n    }\n\n    return feat;\n  }\n\n  willDestroy() {\n    this.removeSubscriptions();\n\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    this.clearInterval();\n\n    window.removeEventListener('online', this.onlineChanged, { passive: true, capture: true } as unknown as boolean);\n    window.removeEventListener('offline', this.onlineChanged, { passive: true, capture: true } as unknown as boolean);\n    document.removeEventListener('visibilitychange', this.backgroundChanged, {\n      passive: true,\n      capture: true,\n    } as unknown as boolean);\n  }\n\n  @cached\n  get _request(): Future<RT> {\n    const { request, query } = this.args;\n    assert(`Cannot use both @request and @query args with the <Request> component`, !request || !query);\n    const { _localRequest, _originalRequest, _originalQuery } = this;\n    const isOriginalRequest = request === _originalRequest && query === _originalQuery;\n\n    if (_localRequest && isOriginalRequest) {\n      return _localRequest;\n    }\n\n    // update state checks for the next time\n    this._originalQuery = query;\n    this._originalRequest = request;\n\n    if (request) {\n      return request;\n    }\n    assert(`You must provide either @request or an @query arg with the <Request> component`, query);\n    return this.store.request<RT, T>(query);\n  }\n\n  @cached\n  get request(): Future<RT> {\n    const request = this._request;\n    this.updateSubscriptions();\n    return request;\n  }\n\n  get store(): Store {\n    const store = this.args.store || this._store;\n    assert(\n      moduleExists('ember-provide-consume-context')\n        ? `No store was provided to the <Request> component. Either provide a store via the @store arg or via the context API provided by ember-provide-consume-context.`\n        : `No store was provided to the <Request> component. Either provide a store via the @store arg or by registering a store service.`,\n      store\n    );\n    return store;\n  }\n\n  get reqState() {\n    return getRequestState<RT, T, E>(this.request);\n  }\n\n  get result() {\n    return this.reqState.result as RT;\n  }\n\n  <template>\n    {{#if (and this.isIdle (has-block \"idle\"))}}\n      {{yield to=\"idle\"}}\n    {{else if this.isIdle}}\n      <Throw @error={{IdleBlockMissingError}} />\n    {{else if this.reqState.isLoading}}\n      {{yield this.reqState.loadingState to=\"loading\"}}\n    {{else if (and this.reqState.isCancelled (has-block \"cancelled\"))}}\n      {{yield (notNull this.reqState.error) this.errorFeatures to=\"cancelled\"}}\n    {{else if (and this.reqState.isError (has-block \"error\"))}}\n      {{yield (notNull this.reqState.error) this.errorFeatures to=\"error\"}}\n    {{else if this.reqState.isSuccess}}\n      {{yield this.result this.contentFeatures to=\"content\"}}\n    {{else if (not this.reqState.isCancelled)}}\n      <Throw @error={{(notNull this.reqState.error)}} />\n    {{/if}}\n    {{yield this.reqState to=\"always\"}}\n  </template>\n}\n"],"names":["and","x","y","Boolean","Throw","Component","constructor","owner","args","error","setComponentTemplate","precompileTemplate","strictMode","Await","state","getPromiseState","promise","result","scope","deferred","WeakMap","deferDecorator","proto","prop","desc","map","get","Map","set","findDeferredDecorator","target","_a","cursor","prototype","decorateFieldV2","decorators","initializer","configurable","enumerable","writable","decorator","Object","defineProperty","decorateMethodV2","origDesc","getOwnPropertyDescriptor","value","call","initializeDeferredDecorator","notNull","macroCondition","getGlobalConfig","WarpDrive","env","DEBUG","test","Error","not","DEFAULT_DEADLINE","IdleBlockMissingError","consume","service","moduleExists","contextConsume","importSync","isNeverString","val","Request","g","i","void 0","tracked","unavailableStart","intervalStart","nextInterval","invalidated","isUpdating","onlineChanged","backgroundChanged","_originalRequest","_originalQuery","_subscription","_subscribedTo","installListeners","beginPolling","request","isDestroyed","scheduleInterval","isIdle","query","n","cached","autorefreshTypes","autorefresh","types","split","Set","autorefreshThreshold","hasValidThreshold","window","has","_latestRequest","Date","now","setTimeout","maybeUpdate","clearInterval","clearTimeout","updateSubscriptions","requestId","_request","lid","removeSubscriptions","store","notifications","subscribe","_id","op","latest","requestManager","_deduped","priority","reqState","isRefreshing","blocking","isLoading","unsubscribe","isOnline","navigator","onLine","isHidden","document","visibilityState","event","type","addEventListener","passive","capture","mode","silent","canAttempt","size","shouldAttempt","deadline","assign","realMode","autorefreshBehavior","cacheOptions","reload","backgroundReload","wasStoreRequest","EnableHydration","_localRequest","finally","retry","refresh","errorFeatures","contentFeatures","feat","latestRequest","abort","willDestroy","removeEventListener","isOriginalRequest","_store","getRequestState"],"mappings":"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","x_google_ignoreList":[1]}