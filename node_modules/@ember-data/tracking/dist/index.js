import { tagForProperty } from '@ember/-internals/metal';
import { _backburner } from '@ember/runloop';
import { createCache, track, updateTag, consumeTag, getValue, dirtyTag } from '@glimmer/validator';
import { macroCondition, getGlobalConfig } from '@embroider/macros';
const emberDirtyTag = dirtyTag;
function buildSignalConfig(options) {
  const ARRAY_SIGNAL = options.wellknown.Array;
  return {
    createSignal(obj, key) {
      if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
        if (key === ARRAY_SIGNAL) {
          return [tagForProperty(obj, key), tagForProperty(obj, 'length'), tagForProperty(obj, '[]')];
        }
      }
      return tagForProperty(obj, key);
    },
    consumeSignal(signal) {
      if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
        if (Array.isArray(signal)) {
          consumeTag(signal[0]);
          consumeTag(signal[1]);
          consumeTag(signal[2]);
          return;
        }
      }
      consumeTag(signal);
    },
    notifySignal(signal) {
      if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
        if (Array.isArray(signal)) {
          emberDirtyTag(signal[0]);
          emberDirtyTag(signal[1]);
          emberDirtyTag(signal[2]);
          return;
        }
      }
      emberDirtyTag(signal);
    },
    createMemo: (object, key, fn) => {
      if (macroCondition(getGlobalConfig().WarpDrive.deprecations.DEPRECATE_COMPUTED_CHAINS)) {
        const propertyTag = tagForProperty(object, key);
        const memo = createCache(fn);
        let ret;
        const wrappedFn = () => {
          ret = getValue(memo);
        };
        return () => {
          const tag = track(wrappedFn);
          updateTag(propertyTag, tag);
          consumeTag(tag);
          return ret;
        };
      } else {
        const memo = createCache(fn);
        return () => getValue(memo);
      }
    },
    willSyncFlushWatchers: () => {
      //@ts-expect-error
      return !!_backburner.currentInstance && _backburner._autorun !== true;
    }
  };
}
export { buildSignalConfig };