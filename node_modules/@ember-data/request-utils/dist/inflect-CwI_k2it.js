import { L as LRUCache, a as capitalize } from "./transform-1PDozfHr.js";
import { macroCondition, getGlobalConfig } from '@embroider/macros';
const defaultRules = {
  plurals: [[/$/, 's'], [/s$/i, 's'], [/^(ax|test)is$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(octop|vir)i$/i, '$1i'], [/(alias|status|bonus)$/i, '$1es'], [/(bu)s$/i, '$1ses'], [/(buffal|tomat)o$/i, '$1oes'], [/([ti])um$/i, '$1a'], [/([ti])a$/i, '$1a'], [/sis$/i, 'ses'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/(hive)$/i, '$1s'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(x|ch|ss|sh)$/i, '$1es'], [/(matr|vert|ind)(?:ix|ex)$/i, '$1ices'], [/^(m|l)ouse$/i, '$1ice'], [/^(m|l)ice$/i, '$1ice'], [/^(ox)$/i, '$1en'], [/^(oxen)$/i, '$1'], [/(quiz)$/i, '$1zes']],
  singular: [[/s$/i, ''], [/(ss)$/i, '$1'], [/(n)ews$/i, '$1ews'], [/([ti])a$/i, '$1um'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, '$1sis'], [/(^analy)(sis|ses)$/i, '$1sis'], [/([^f])ves$/i, '$1fe'], [/(hive)s$/i, '$1'], [/(tive)s$/i, '$1'], [/([lr])ves$/i, '$1f'], [/([^aeiouy]|qu)ies$/i, '$1y'], [/(s)eries$/i, '$1eries'], [/(m)ovies$/i, '$1ovie'], [/(x|ch|ss|sh)es$/i, '$1'], [/^(m|l)ice$/i, '$1ouse'], [/(bus)(es)?$/i, '$1'], [/(o)es$/i, '$1'], [/(shoe)s$/i, '$1'], [/(cris|test)(is|es)$/i, '$1is'], [/^(a)x[ie]s$/i, '$1xis'], [/(octop|vir)(us|i)$/i, '$1us'], [/(alias|status|bonus)(es)?$/i, '$1'], [/^(ox)en/i, '$1'], [/(vert|ind)ices$/i, '$1ex'], [/(matr)ices$/i, '$1ix'], [/(quiz)zes$/i, '$1'], [/(database)s$/i, '$1']],
  irregularPairs: [['person', 'people'], ['man', 'men'], ['child', 'children'], ['sex', 'sexes'], ['move', 'moves'], ['cow', 'kine'], ['zombie', 'zombies']],
  uncountable: ['equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep', 'jeans', 'police']
};

/**
 * @module @ember-data/request-utils/string
 */

const BLANK_REGEX = /^\s*$/;
const LAST_WORD_DASHED_REGEX = /([\w/-]+[_/\s-])([a-z\d]+$)/;
const LAST_WORD_CAMELIZED_REGEX = /([\w/\s-]+)([A-Z][a-z\d]*$)/;
const CAMELIZED_REGEX = /[A-Z][a-z\d]*$/;
const SINGULARS = new LRUCache(word => {
  return _singularize(word);
});
const PLURALS = new LRUCache(word => {
  return _pluralize(word);
});
const UNCOUNTABLE = new Set(defaultRules.uncountable);
const IRREGULAR = new Map();
const INVERSE_IRREGULAR = new Map();
const SINGULAR_RULES = new Map(defaultRules.singular.reverse());
const PLURAL_RULES = new Map(defaultRules.plurals.reverse());

/**
 * Marks a word as uncountable. Uncountable words are not pluralized
 * or singularized.
 *
 * @method uncountable
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {String} word
 * @return {void}
 * @since 4.13.0
 */
function uncountable(word) {
  UNCOUNTABLE.add(word.toLowerCase());
}

/**
 * Marks a list of words as uncountable. Uncountable words are not pluralized
 * or singularized.
 *
 * @method loadUncountable
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {Array<String>} uncountables
 * @return {void}
 * @since 4.13.0
 */
function loadUncountable(uncountables) {
  uncountables.forEach(word => {
    uncountable(word);
  });
}

/**
 * Marks a word as irregular. Irregular words have unique
 * pluralization and singularization rules.
 *
 * @method irregular
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {String} single
 * @param {String} plur
 * @return {void}
 * @since 4.13.0
 */
function irregular(single, plur) {
  //pluralizing
  IRREGULAR.set(single.toLowerCase(), plur);
  IRREGULAR.set(plur.toLowerCase(), plur);

  //singularizing
  INVERSE_IRREGULAR.set(plur.toLowerCase(), single);
  INVERSE_IRREGULAR.set(single.toLowerCase(), single);
}

/**
 * Marks a list of word pairs as irregular. Irregular words have unique
 * pluralization and singularization rules.
 *
 * @method loadIrregular
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {Array<Array<String>>} irregularPairs
 * @return {void}
 * @since 4.13.0
 */
function loadIrregular(irregularPairs) {
  irregularPairs.forEach(pair => {
    //pluralizing
    IRREGULAR.set(pair[0].toLowerCase(), pair[1]);
    IRREGULAR.set(pair[1].toLowerCase(), pair[1]);

    //singularizing
    INVERSE_IRREGULAR.set(pair[1].toLowerCase(), pair[0]);
    INVERSE_IRREGULAR.set(pair[0].toLowerCase(), pair[0]);
  });
}
loadIrregular(defaultRules.irregularPairs);

/**
 * Clears the caches for singularize and pluralize.
 *
 * @method clear
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @return {void}
 * @since 4.13.0
 */
function clear() {
  SINGULARS.clear();
  PLURALS.clear();
}

/**
 * Resets the inflection rules to the defaults.
 *
 * @method resetToDefaults
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @return {void}
 * @since 4.13.0
 */
function resetToDefaults() {
  clearRules();
  defaultRules.uncountable.forEach(v => UNCOUNTABLE.add(v));
  defaultRules.singular.forEach(v => SINGULAR_RULES.set(v[0], v[1]));
  defaultRules.plurals.forEach(v => PLURAL_RULES.set(v[0], v[1]));
  loadIrregular(defaultRules.irregularPairs);
}

/**
 * Clears all inflection rules
 * and resets the caches for singularize and pluralize.
 *
 * @method clearRules
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @return {void}
 * @since 4.13.0
 */
function clearRules() {
  SINGULARS.clear();
  PLURALS.clear();
  UNCOUNTABLE.clear();
  IRREGULAR.clear();
  INVERSE_IRREGULAR.clear();
  SINGULAR_RULES.clear();
  PLURAL_RULES.clear();
}

/**
 * Singularizes a word.
 *
 * @method singularize
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {String} word
 * @return {String}
 * @since 4.13.0
 */
function singularize(word) {
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`singularize expects to receive a non-empty string`);
    }
  })(typeof word === 'string' && word.length > 0) : {};
  if (!word) return '';
  return SINGULARS.get(word);
}

/**
 * Pluralizes a word.
 *
 * @method pluralize
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {String} word
 * @return {String}
 * @since 4.13.0
 */
function pluralize(word) {
  macroCondition(getGlobalConfig().WarpDrive.env.DEBUG) ? (test => {
    if (!test) {
      throw new Error(`pluralize expects to receive a non-empty string`);
    }
  })(typeof word === 'string' && word.length > 0) : {};
  if (!word) return '';
  return PLURALS.get(word);
}
function unshiftMap(v, map) {
  // reorder
  const rules = [v, ...map.entries()];
  map.clear();
  rules.forEach(rule => {
    map.set(rule[0], rule[1]);
  });
}

/**
 * Adds a pluralization rule.
 *
 * @method plural
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {RegExp} regex
 * @param {String} string
 * @return {void}
 * @since 4.13.0
 */
function plural(regex, string) {
  // rule requires reordering if exists, so remove it first
  if (PLURAL_RULES.has(regex)) {
    PLURAL_RULES.delete(regex);
  }

  // reorder
  unshiftMap([regex, string], PLURAL_RULES);
}

/**
 * Adds a singularization rule.
 *
 * @method singular
 * @public
 * @static
 * @for @ember-data/request-utils/string
 * @param {RegExp} regex
 * @param {String} string
 * @return {void}
 * @since 4.13.0
 */
function singular(regex, string) {
  // rule requires reordering if exists, so remove it first
  if (SINGULAR_RULES.has(regex)) {
    SINGULAR_RULES.delete(regex);
  }

  // reorder
  unshiftMap([regex, string], SINGULAR_RULES);
}
function _pluralize(word) {
  return inflect(word, PLURAL_RULES, IRREGULAR);
}
function _singularize(word) {
  return inflect(word, SINGULAR_RULES, INVERSE_IRREGULAR);
}
function inflect(word, typeRules, irregulars) {
  // empty strings
  const isBlank = !word || BLANK_REGEX.test(word);
  if (isBlank) {
    return word;
  }

  // basic uncountables
  const lowercase = word.toLowerCase();
  if (UNCOUNTABLE.has(lowercase)) {
    return word;
  }

  // adv uncountables
  const wordSplit = LAST_WORD_DASHED_REGEX.exec(word) || LAST_WORD_CAMELIZED_REGEX.exec(word);
  const lastWord = wordSplit ? wordSplit[2].toLowerCase() : null;
  if (lastWord && UNCOUNTABLE.has(lastWord)) {
    return word;
  }

  // handle irregulars
  const isCamelized = CAMELIZED_REGEX.test(word);
  for (let [rule, substitution] of irregulars) {
    if (lowercase.match(rule + '$')) {
      if (isCamelized && lastWord && irregulars.has(lastWord)) {
        substitution = capitalize(substitution);
        rule = capitalize(rule);
      }
      return word.replace(new RegExp(rule, 'i'), substitution);
    }
  }

  // do the actual inflection
  for (const [rule, substitution] of typeRules) {
    if (rule.test(word)) {
      return word.replace(rule, substitution);
    }
  }
  return word;
}
export { singular as a, plural as b, loadUncountable as c, clear as d, clearRules as e, defaultRules as f, irregular as i, loadIrregular as l, pluralize as p, resetToDefaults as r, singularize as s, uncountable as u };