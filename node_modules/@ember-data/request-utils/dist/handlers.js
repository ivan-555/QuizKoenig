/**
 * @module @ember-data/request-utils/handlers
 */

function isCompressibleMethod(method) {
  return method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE';
}
const SupportsRequestStreams = (() => {
  let duplexAccessed = false;
  const hasContentType = new Request('', {
    body: new ReadableStream(),
    method: 'POST',
    // @ts-expect-error untyped
    get duplex() {
      duplexAccessed = true;
      return 'half';
    }
  }).headers.has('Content-Type');
  return duplexAccessed && !hasContentType;
})();

/**
 * Options for configuring the AutoCompress handler.
 *
 * @typedoc
 */

const DEFAULT_CONSTRAINTS = {
  Blob: 1000,
  ArrayBuffer: 1000,
  TypedArray: 1000,
  DataView: 1000,
  String: 1000
};
const TypedArray = Object.getPrototypeOf(Uint8Array.prototype);

/**
 * A request handler that automatically compresses the request body
 * if the request body is a string, array buffer, blob, or form data.
 *
 * This uses the [CompressionStream API](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)
 *
 * The compression format as well as the kinds of data to compress can be
 * configured using the `format` and `constraints` options.
 *
 * ```diff
 * +import { AutoCompress } from '@ember-data/request-utils/handlers';
 * import Fetch from '@ember-data/request/fetch';
 * import RequestManager from '@ember-data/request';
 * import Store from '@ember-data/store';
 *
 * class AppStore extends Store {
 *   requestManager = new RequestManager()
 *     .use([
 * +       new AutoCompress(),
 *        Fetch
 *     ]);
 * }
 * ```
 *
 * @class AutoCompress
 * @extends Handler
 * @public
 * @since 5.5.0
 */
class AutoCompress {
  constructor(options = {}) {
    const opts = {
      format: options.format ?? 'gzip',
      constraints: Object.assign({}, DEFAULT_CONSTRAINTS, options.constraints),
      allowStreaming: options.allowStreaming ?? false,
      forceStreaming: options.forceStreaming ?? false
    };
    this.options = opts;
  }
  request({
    request
  }, next) {
    const {
      constraints
    } = this.options;
    const {
      body
    } = request;
    const shouldCompress = isCompressibleMethod(request.method) && request.options?.compress !== false && (
    // prettier-ignore
    request.options?.compress ? true : typeof body === 'string' || body instanceof String ? canCompress('String', constraints, body.length) : body instanceof Blob ? canCompress('Blob', constraints, body.size) : body instanceof ArrayBuffer ? canCompress('ArrayBuffer', constraints, body.byteLength) : body instanceof DataView ? canCompress('DataView', constraints, body.byteLength) : body instanceof TypedArray ? canCompress('TypedArray', constraints, body.byteLength) : false);
    if (!shouldCompress) return next(request);

    // A convenient way to convert all of the supported body types to a readable
    // stream is to use a `Response` object body
    const response = new Response(request.body);
    const stream = response.body?.pipeThrough(new CompressionStream(this.options.format));
    const headers = new Headers(request.headers);
    headers.set('Content-Encoding', encodingForFormat(this.options.format));

    //
    // For browsers that support it, `fetch` can receive a `ReadableStream` as
    // the body, so all we need to do is to create a new `ReadableStream` and
    // compress it on the fly
    //
    const forceStreaming = request.options?.forceStreaming ?? this.options.forceStreaming;
    const allowStreaming = request.options?.allowStreaming ?? this.options.allowStreaming;
    if (forceStreaming || SupportsRequestStreams && allowStreaming) {
      const req = Object.assign({}, request, {
        body: stream
      });
      if (SupportsRequestStreams) {
        // @ts-expect-error untyped
        req.duplex = 'half';
      }
      return next(req);

      //
      // For non-chromium browsers, we have to "pull" the stream to get the final
      // bytes and supply the final byte array as the new request body.
      //
    } else {
      // we need to pull the stream to get the final bytes
      const resp = new Response(stream);
      return resp.blob().then(blob => {
        const req = Object.assign({}, request, {
          body: blob,
          headers
        });
        return next(req);
      });
    }
  }
}
function canCompress(type, constraints, size) {
  // if we have a value of 0, we can compress anything
  if (constraints[type] === 0) return true;
  if (constraints[type] === -1) return false;
  return size >= constraints[type];
}
function encodingForFormat(format) {
  switch (format) {
    case 'gzip':
    case 'deflate':
    case 'deflate-raw':
      return format;
    default:
      throw new Error(`Unsupported compression format: ${format}`);
  }
}
export { AutoCompress, SupportsRequestStreams };