{"version":3,"file":"handlers.js","sources":["../src/-private/handlers/auto-compress.ts"],"sourcesContent":["/**\n * @module @ember-data/request-utils/handlers\n */\nimport type { Future, Handler, NextFn, RequestContext } from '@ember-data/request';\nimport type { HTTPMethod } from '@warp-drive/core-types/request';\n\nfunction isCompressibleMethod(method?: HTTPMethod): boolean {\n  return method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE';\n}\n\nexport const SupportsRequestStreams = (() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request('', {\n    body: new ReadableStream(),\n    method: 'POST',\n    // @ts-expect-error untyped\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n})();\n\ninterface Constraints {\n  /**\n   * The minimum size at which to compress blobs\n   *\n   * @default 1000\n   * @typedoc\n   */\n  Blob?: number;\n  /**\n   * The minimum size at which to compress array buffers\n   *\n   * @default 1000\n   * @typedoc\n   */\n  ArrayBuffer?: number;\n  /**\n   * The minimum size at which to compress typed arrays\n   *\n   * @default 1000\n   * @typedoc\n   */\n  TypedArray?: number;\n  /**\n   * The minimum size at which to compress data views\n   *\n   * @default 1000\n   * @typedoc\n   */\n  DataView?: number;\n  /**\n   * The minimum size at which to compress strings\n   *\n   * @default 1000\n   * @typedoc\n   */\n  String?: number;\n}\n\n/**\n * Options for configuring the AutoCompress handler.\n *\n * @typedoc\n */\ninterface CompressionOptions {\n  /**\n   * The compression format to use. Must be a valid\n   * compression format supported by [CompressionStream](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)\n   *\n   * The default is `gzip`.\n   *\n   * @typedoc\n   */\n  format?: CompressionFormat;\n\n  /**\n   * Some browsers support `ReadableStream` as a request body. This option\n   * enables passing the compression stream as the request body instead of\n   * the final compressed body when the browser supports doing so.\n   *\n   * This comes with several caveats:\n   *\n   * - the request will be put into `duplex: 'half'` mode. This should be\n   *   transparent to you, but it is worth noting.\n   * - the request mode cannot be `no-cors` as requests with a `ReadableStream`\n   *   have no content length and thus are a new form of request that triggers\n   *   cors requirements and a preflight request.\n   * - http/1.x is not supported.\n   *\n   * For additional reading about the restrictions of using `ReadableStream`\n   * as a request body, see the [Chromium Documentation](https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#restrictions)\n   *\n   * Streaming can be enabled per-request in browsers which support it by\n   * setting `request.options.allowStreaming` to `true`.\n   *\n   * Streaming can be forced even when the browser does not support it by setting\n   * `request.options.forceStreaming` to `true`. This is useful if later handlers\n   * in the chain can handle the request body as a stream.\n   *\n   * @default false\n   * @typedoc\n   */\n  allowStreaming?: boolean;\n\n  /**\n   * If `true`, the request will be forced into streaming mode even\n   * if the browser does not support it. This is useful if later handlers\n   * in the chain can handle the request body as a stream.\n   *\n   * @default false\n   * @typedoc\n   */\n  forceStreaming?: boolean;\n\n  /**\n   * The constraints for the request body. This is used to determine\n   * whether to compress the request body or not.\n   *\n   * The defaults are:\n   *\n   * ```ts\n   * {\n   *   Blob: 1000, // blob.size\n   *   ArrayBuffer: 1000, // buffer.byteLength\n   *   TypedArray: 1000, // array.byteLength\n   *   DataView: 1000, // view.byteLength\n   *   String: 1000, // string.length\n   * }\n   * ```\n   *\n   * The following body types are never compressed unless explicitly\n   * configured by the request:\n   * - `FormData`\n   * - `URLSearchParams`\n   * - `ReadableStream`\n   *\n   * A request.options.compress value of `false` will disable\n   * compression for a request body of any type. While a value of\n   * `true` will enable compression for the request.\n   *\n   * An undefined value will use the default, a value of `0` will\n   * enable compression for all values, and a value of `-1` will\n   * disable compression.\n   *\n   * @typedoc\n   */\n  constraints?: Constraints;\n}\n\nconst DEFAULT_CONSTRAINTS = {\n  Blob: 1000,\n  ArrayBuffer: 1000,\n  TypedArray: 1000,\n  DataView: 1000,\n  String: 1000,\n};\nconst TypedArray = Object.getPrototypeOf(Uint8Array.prototype) as typeof Uint8Array;\n\n/**\n * A request handler that automatically compresses the request body\n * if the request body is a string, array buffer, blob, or form data.\n *\n * This uses the [CompressionStream API](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)\n *\n * The compression format as well as the kinds of data to compress can be\n * configured using the `format` and `constraints` options.\n *\n * ```diff\n * +import { AutoCompress } from '@ember-data/request-utils/handlers';\n * import Fetch from '@ember-data/request/fetch';\n * import RequestManager from '@ember-data/request';\n * import Store from '@ember-data/store';\n *\n * class AppStore extends Store {\n *   requestManager = new RequestManager()\n *     .use([\n * +       new AutoCompress(),\n *        Fetch\n *     ]);\n * }\n * ```\n *\n * @class AutoCompress\n * @extends Handler\n * @public\n * @since 5.5.0\n */\nexport class AutoCompress implements Handler {\n  declare options: Required<CompressionOptions> & { constraints: Required<Constraints> };\n\n  constructor(options: CompressionOptions = {}) {\n    const opts = {\n      format: options.format ?? 'gzip',\n      constraints: Object.assign({}, DEFAULT_CONSTRAINTS, options.constraints),\n      allowStreaming: options.allowStreaming ?? false,\n      forceStreaming: options.forceStreaming ?? false,\n    };\n    this.options = opts;\n  }\n\n  request<T>({ request }: RequestContext, next: NextFn<T>): Promise<T> | Future<T> {\n    const { constraints } = this.options;\n    const { body } = request;\n\n    const shouldCompress =\n      isCompressibleMethod(request.method) &&\n      request.options?.compress !== false &&\n      // prettier-ignore\n      (request.options?.compress ? true\n      : typeof body === 'string' || body instanceof String ? canCompress('String', constraints, body.length)\n      : body instanceof Blob ? canCompress('Blob', constraints, body.size)\n      : body instanceof ArrayBuffer ? canCompress('ArrayBuffer', constraints, body.byteLength)\n      : body instanceof DataView ? canCompress('DataView', constraints, body.byteLength)\n      : body instanceof TypedArray ? canCompress('TypedArray', constraints, body.byteLength)\n      : false);\n\n    if (!shouldCompress) return next(request);\n\n    // A convenient way to convert all of the supported body types to a readable\n    // stream is to use a `Response` object body\n    const response = new Response(request.body);\n    const stream = response.body?.pipeThrough(new CompressionStream(this.options.format));\n    const headers = new Headers(request.headers);\n    headers.set('Content-Encoding', encodingForFormat(this.options.format));\n\n    //\n    // For browsers that support it, `fetch` can receive a `ReadableStream` as\n    // the body, so all we need to do is to create a new `ReadableStream` and\n    // compress it on the fly\n    //\n    const forceStreaming = request.options?.forceStreaming ?? this.options.forceStreaming;\n    const allowStreaming = request.options?.allowStreaming ?? this.options.allowStreaming;\n    if (forceStreaming || (SupportsRequestStreams && allowStreaming)) {\n      const req = Object.assign({}, request, {\n        body: stream,\n      });\n      if (SupportsRequestStreams) {\n        // @ts-expect-error untyped\n        req.duplex = 'half';\n      }\n\n      return next(req);\n\n      //\n      // For non-chromium browsers, we have to \"pull\" the stream to get the final\n      // bytes and supply the final byte array as the new request body.\n      //\n    } else {\n      // we need to pull the stream to get the final bytes\n      const resp = new Response(stream);\n      return resp.blob().then((blob) => {\n        const req = Object.assign({}, request, {\n          body: blob,\n          headers,\n        });\n        return next(req);\n      }) as Promise<T>;\n    }\n  }\n}\n\nfunction canCompress(type: keyof Constraints, constraints: Required<Constraints>, size: number): boolean {\n  // if we have a value of 0, we can compress anything\n  if (constraints[type] === 0) return true;\n  if (constraints[type] === -1) return false;\n  return size >= constraints[type];\n}\n\nfunction encodingForFormat(format: CompressionFormat): string {\n  switch (format) {\n    case 'gzip':\n    case 'deflate':\n    case 'deflate-raw':\n      return format;\n    default:\n      throw new Error(`Unsupported compression format: ${format as unknown as string}`);\n  }\n}\n"],"names":["isCompressibleMethod","method","SupportsRequestStreams","duplexAccessed","hasContentType","Request","body","ReadableStream","duplex","headers","has","DEFAULT_CONSTRAINTS","Blob","ArrayBuffer","TypedArray","DataView","String","Object","getPrototypeOf","Uint8Array","prototype","AutoCompress","constructor","options","opts","format","constraints","assign","allowStreaming","forceStreaming","request","next","shouldCompress","compress","canCompress","length","size","byteLength","response","Response","stream","pipeThrough","CompressionStream","Headers","set","encodingForFormat","req","resp","blob","then","type","Error"],"mappings":"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"}