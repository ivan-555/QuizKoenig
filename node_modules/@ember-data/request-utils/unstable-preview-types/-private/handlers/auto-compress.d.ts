declare module '@ember-data/request-utils/-private/handlers/auto-compress' {
  /**
   * @module @ember-data/request-utils/handlers
   */
  import type { Future, Handler, NextFn, RequestContext } from '@ember-data/request';
  export const SupportsRequestStreams: boolean;
  interface Constraints {
      /**
       * The minimum size at which to compress blobs
       *
       * @default 1000
       * @typedoc
       */
      Blob?: number;
      /**
       * The minimum size at which to compress array buffers
       *
       * @default 1000
       * @typedoc
       */
      ArrayBuffer?: number;
      /**
       * The minimum size at which to compress typed arrays
       *
       * @default 1000
       * @typedoc
       */
      TypedArray?: number;
      /**
       * The minimum size at which to compress data views
       *
       * @default 1000
       * @typedoc
       */
      DataView?: number;
      /**
       * The minimum size at which to compress strings
       *
       * @default 1000
       * @typedoc
       */
      String?: number;
  }
  /**
   * Options for configuring the AutoCompress handler.
   *
   * @typedoc
   */
  interface CompressionOptions {
      /**
       * The compression format to use. Must be a valid
       * compression format supported by [CompressionStream](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)
       *
       * The default is `gzip`.
       *
       * @typedoc
       */
      format?: CompressionFormat;
      /**
       * Some browsers support `ReadableStream` as a request body. This option
       * enables passing the compression stream as the request body instead of
       * the final compressed body when the browser supports doing so.
       *
       * This comes with several caveats:
       *
       * - the request will be put into `duplex: 'half'` mode. This should be
       *   transparent to you, but it is worth noting.
       * - the request mode cannot be `no-cors` as requests with a `ReadableStream`
       *   have no content length and thus are a new form of request that triggers
       *   cors requirements and a preflight request.
       * - http/1.x is not supported.
       *
       * For additional reading about the restrictions of using `ReadableStream`
       * as a request body, see the [Chromium Documentation](https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#restrictions)
       *
       * Streaming can be enabled per-request in browsers which support it by
       * setting `request.options.allowStreaming` to `true`.
       *
       * Streaming can be forced even when the browser does not support it by setting
       * `request.options.forceStreaming` to `true`. This is useful if later handlers
       * in the chain can handle the request body as a stream.
       *
       * @default false
       * @typedoc
       */
      allowStreaming?: boolean;
      /**
       * If `true`, the request will be forced into streaming mode even
       * if the browser does not support it. This is useful if later handlers
       * in the chain can handle the request body as a stream.
       *
       * @default false
       * @typedoc
       */
      forceStreaming?: boolean;
      /**
       * The constraints for the request body. This is used to determine
       * whether to compress the request body or not.
       *
       * The defaults are:
       *
       * ```ts
       * {
       *   Blob: 1000, // blob.size
       *   ArrayBuffer: 1000, // buffer.byteLength
       *   TypedArray: 1000, // array.byteLength
       *   DataView: 1000, // view.byteLength
       *   String: 1000, // string.length
       * }
       * ```
       *
       * The following body types are never compressed unless explicitly
       * configured by the request:
       * - `FormData`
       * - `URLSearchParams`
       * - `ReadableStream`
       *
       * A request.options.compress value of `false` will disable
       * compression for a request body of any type. While a value of
       * `true` will enable compression for the request.
       *
       * An undefined value will use the default, a value of `0` will
       * enable compression for all values, and a value of `-1` will
       * disable compression.
       *
       * @typedoc
       */
      constraints?: Constraints;
  }
  /**
   * A request handler that automatically compresses the request body
   * if the request body is a string, array buffer, blob, or form data.
   *
   * This uses the [CompressionStream API](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)
   *
   * The compression format as well as the kinds of data to compress can be
   * configured using the `format` and `constraints` options.
   *
   * ```diff
   * +import { AutoCompress } from '@ember-data/request-utils/handlers';
   * import Fetch from '@ember-data/request/fetch';
   * import RequestManager from '@ember-data/request';
   * import Store from '@ember-data/store';
   *
   * class AppStore extends Store {
   *   requestManager = new RequestManager()
   *     .use([
   * +       new AutoCompress(),
   *        Fetch
   *     ]);
   * }
   * ```
   *
   * @class AutoCompress
   * @extends Handler
   * @public
   * @since 5.5.0
   */
  export class AutoCompress implements Handler {
      options: Required<CompressionOptions> & {
          constraints: Required<Constraints>;
      };
      constructor(options?: CompressionOptions);
      request<T>({ request }: RequestContext, next: NextFn<T>): Promise<T> | Future<T>;
  }
  export {};
}
//# sourceMappingURL=auto-compress.d.ts.map