declare module '@ember-data/store/-private/new-core-tmp/request-state' {
  import type { Future, ImmutableRequestInfo, ResponseInfo, StructuredErrorDocument } from '@ember-data/request';
  import type { PendingPromise, RejectedPromise, ResolvedPromise } from '@ember-data/store/-private/new-core-tmp/promise-state';
  /**
   * Lazily consumes the stream of a request, providing a number of
   * reactive properties that can be used to build UIs that respond
   * to the progress of a request.
   *
   * @typedoc
   */
  export class RequestLoadingState {
      _sizeHint: number;
      _bytesLoaded: number;
      _startTime: number;
      _endTime: number;
      _lastPacketTime: number;
      _isPending: boolean;
      _isStarted: boolean;
      _isComplete: boolean;
      _isCancelled: boolean;
      _isErrored: boolean;
      _error: Error | null;
      _stream: TransformStream | null;
      _future: Future<unknown>;
      _triggered: boolean;
      _trigger(): void;
      promise: Promise<void> | null;
      get isPending(): boolean;
      get sizeHint(): number;
      get stream(): ReadableStream | null;
      get isStarted(): boolean;
      get bytesLoaded(): number;
      get startTime(): number;
      get endTime(): number;
      get lastPacketTime(): number;
      get isComplete(): boolean;
      get isCancelled(): boolean;
      get isErrored(): boolean;
      get error(): Error | null;
      get elapsedTime(): number;
      get completedRatio(): number;
      get remainingRatio(): number;
      get duration(): number;
      get speed(): number;
      constructor(future: Future<unknown>);
      abort: () => void;
  }
  /**
   * The state of a request in the "pending"
   * state. This is the default initial state.
   *
   * Extends the {@link PendingPromise} interface.
   *
   * @typedoc
   */
  export interface PendingRequest extends PendingPromise {
      /**
       * Whether the request is cancelled.
       *
       * @typedoc
       */
      isCancelled: false;
      loadingState: RequestLoadingState;
      request: null;
      response: null;
  }
  /**
   * The state of a request in the "fulfilled" state.
   * This is the state of a request that has resolved
   * successfully.
   *
   * Extends the {@link ResolvedPromise} interface.
   *
   * @typedoc
   */
  export interface ResolvedRequest<T, RT> extends ResolvedPromise<RT> {
      /**
       * Whether the request is cancelled.
       *
       * @typedoc
       */
      isCancelled: false;
      loadingState: RequestLoadingState;
      request: ImmutableRequestInfo<T, RT> | null;
      response: Response | ResponseInfo | null;
  }
  /**
   * The state of a request in the "rejected" state.
   * This is the state of a request that has rejected
   * with an error.
   *
   * Extends the {@link RejectedPromise} interface.
   *
   * @typedoc
   */
  export interface RejectedRequest<T, RT, E extends StructuredErrorDocument = StructuredErrorDocument> extends RejectedPromise<E> {
      /**
       * Whether the request is cancelled.
       *
       * @typedoc
       */
      isCancelled: false;
      loadingState: RequestLoadingState;
      request: ImmutableRequestInfo<T, RT> | null;
      response: Response | ResponseInfo | null;
  }
  /**
   * The state of a request in the "cancelled" state.
   * This is the state of a promise that has been
   * cancelled.
   *
   * @typedoc
   */
  export interface CancelledRequest<T, RT, E extends StructuredErrorDocument = StructuredErrorDocument> {
      /**
       * The status of the request.
       *
       * @typedoc
       */
      status: 'cancelled';
      /**
       * Whether the request is pending.
       *
       * @typedoc
       */
      isPending: false;
      /**
       * Whether the request is pending.
       *
       * @typedoc
       */
      isLoading: false;
      /**
       * Whether the request has resolved
       * successfully.
       *
       * @typedoc
       */
      isSuccess: false;
      /**
       * Whether the request has rejected
       * with an error.
       *
       * @typedoc
       */
      isError: true;
      /**
       * Once the request has resolved, this will
       * be the value the request resolved to.
       *
       * @typedoc
       */
      value: null;
      /**
       * Once the request has resolved, this will
       * be the value the request resolved to.
       *
       * @deprecated use `value` instead
       * @typedoc
       */
      result: null;
      /**
       * Once the request has rejected, this will
       * be the error the request rejected with.
       *
       *
       * @deprecated use `reason` instead
       * @typedoc
       */
      error: E;
      /**
       * Once the request has rejected, this will
       * be the error the request rejected with.
       *
       * @typedoc
       */
      reason: E;
      /**
       * Whether the request is cancelled.
       *
       * @typedoc
       */
      isCancelled: true;
      loadingState: RequestLoadingState;
      request: ImmutableRequestInfo<T, RT> | null;
      response: Response | ResponseInfo | null;
  }
  /**
   * RequestState extends the concept of PromiseState to provide a reactive
   * wrapper for a request `Future` which allows you write declarative code
   * around a Future's control flow.
   *
   * It is useful in both Template and JavaScript contexts, allowing you
   * to quickly derive behaviors and data from pending, error and success
   * states.
   *
   * The key difference between a Promise and a Future is that Futures provide
   * access to a stream of their content, the identity of the request (if any)
   * as well as the ability to attempt to abort the request.
   *
   * ```ts
   * interface Future<T> extends Promise<T>> {
   *   getStream(): Promise<ReadableStream>;
   *   abort(): void;
   *   lid: StableDocumentIdentifier | null;
   * }
   * ```
   *
   * These additional APIs allow us to craft even richer state experiences.
   *
   * To get the state of a request, use `getRequestState`.
   *
   * See also:
   * - {@link PendingRequest}
   * - {@link ResolvedRequest}
   * - {@link RejectedRequest}
   * - {@link CancelledRequest}
   *
   * @typedoc
   */
  export type RequestCacheRequestState<T = unknown, RT = unknown, E extends StructuredErrorDocument = StructuredErrorDocument> = PendingRequest | ResolvedRequest<T, RT> | RejectedRequest<T, RT, E> | CancelledRequest<T, RT, E>;
  export function createRequestState<T, RT, E>(future: Future<RT>): Readonly<RequestCacheRequestState<T, RT, StructuredErrorDocument<E>>>;
  /**
   * `getRequestState` can be used in both JavaScript and Template contexts.
   *
   * ```ts
   * import { getRequestState } from '@warp-drive/ember';
   *
   * const state = getRequestState(future);
   * ```
   *
   * For instance, we could write a getter on a component that updates whenever
   * the request state advances or the future changes, by combining the function
   * with the use of `@cached`
   *
   * ```ts
   * class Component {
   *   @cached
   *   get title() {
   *     const state = getRequestState(this.args.request);
   *     if (state.isPending) {
   *       return 'loading...';
   *     }
   *     if (state.isError) { return null; }
   *     return state.result.title;
   *   }
   * }
   * ```
   *
   * Or in a template as a helper:
   *
   * ```gjs
   * import { getRequestState } from '@warp-drive/ember';
   *
   * <template>
   *   {{#let (getRequestState @request) as |state|}}
   *     {{#if state.isPending}}
   *       <Spinner />
   *     {{else if state.isError}}
   *       <ErrorForm @error={{state.error}} />
   *     {{else}}
   *       <h1>{{state.result.title}}</h1>
   *     {{/if}}
   *   {{/let}}
   * </template>
   * ```
   *
   * If looking to use in a template, consider also the `<Request />` component
   * which offers a numbe of additional capabilities for requests *beyond* what
   * `RequestState` provides.
   *
   * @typedoc
   */
  export function getRequestState<RT, T, E>(future: Future<RT>): Readonly<RequestCacheRequestState<T, RT, StructuredErrorDocument<E>>>;
}
//# sourceMappingURL=request-state.d.ts.map